{
    "componentChunkName": "component---src-templates-blog-blog-post-template-jsx",
    "path": "/blog/25/01/2021/Morphologica",
    "result": {"data":{"mdx":{"id":"7e8ffaac-7f17-55de-9778-13887c6e9f24","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"author\": [\"Seb James\"],\n  \"title\": \"Data visualisation in c++ with computational models\",\n  \"description\": \"In this blog post I'm going to talk about data visualisation - making graphs - within c++ programs. I'll describe why you might want to do this and I'll try to justify why I've spent a sizeable part of my time over the last couple of years developing graphing code in c++, rather than using Python or R like everyone else!\",\n  \"date\": \"2021-01-25\",\n  \"category\": [\"Articles\"],\n  \"tag\": [\"Dataviz\", \"C++\", \"Interactive\"],\n  \"thumbnail\": \"./Surface.png\",\n  \"featured\": true\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar TwitterBtn = makeShortcode(\"TwitterBtn\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In this blog post I'm going to talk about data visualisation - making graphs - within c++ programs. I'll describe why you might want to do this and I'll try to justify why I've spent a sizeable part of my time over the last couple of years developing graphing code in c++, rather than using Python or R like everyone else! The code I'll discuss is available at \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/ABRG-Models/morphologica\"\n  }, \"https://github.com/ABRG-Models/morphologica\"), \". \"), mdx(\"img\", {\n    alt: \"A selection of visualisations made with morphologica\",\n    src: \"/a2f93de9a8e200af0de860d457e88ba6/Panel.png\"\n  }), mdx(\"em\", null, \" A selection of visualisations made with morphologica. \", mdx(\"b\", null, \"A\"), \" 2D graphs. \", mdx(\"b\", null, \"B\"), \" A self-organising map simulation (orientation preference maps). \", mdx(\"b\", null, \"C\"), \" Three dimensional quiver plot. \", mdx(\"b\", null, \"D\"), \" gene driven reaction diffusion model. \", mdx(\"b\", null, \"E\"), \" Debugging a large model. \"), mdx(\"p\", null, \"Most of the academic blog posts and videos about data visualisation that I see refer to scripted languages like Python, R or MATLAB. These languages have the ability to render high quality graphs and they provide convenient function calls to create standard graphs such as scatter plots and bar graphs, as well as more esoteric visualisations such as Sankey plots or Dendrograms (see the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.d3-graph-gallery.com/index.html\"\n  }, \"d3 graph gallery\"), \" for lots of interesting examples). It's easy to generate output in a standard format like PNG or PDF and so if you\\u2019re visualising an existing dataset then one of these scripted languages \\u2013 Python with \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://matplotlib.org/\"\n  }, \"matplotlib\"), \" or R with \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.r-graph-gallery.com/ggplot2-package.html\"\n  }, \"ggplot2\"), \" \\u2013 is probably the best way to communicate information about the data to your audience. \"), mdx(\"p\", null, \"Scripted languages have become the richest platforms for data visualisation because they are so convenient and flexible. There is no need to compile your program or concern yourself with the complexities of linking libraries; you just write the script in a text editor and execute it with the interpreter. The script can be easily archived, making your work more reproducible and it is straightforward to apply a given data visualisation routine to many different datasets. For these reasons, scripted data visualisations are more popular in the academic community than visualisation using a dedicated graphing application.\"), mdx(\"p\", null, \"Although interpreted programs are always slower than compiled code, with today's average laptop or PC the compute time required to draw most graphs is minimal and so there is no incentive to use a faster, compiled language such as c++ with its additional development overhead (more lines of code for headers, a need to compile before running, the need to specify library links).\"), mdx(\"p\", null, \"So why this post about data visualisation in c++? While the wider data-vis community won\\u2019t see c++ as a primary tool, there is a use case for researchers who write numerically intensive models - any model which 'contains' a lot of numbers and benefits from making maximal use of available computational resources. My work falls into this category. Although I don't need racks of servers to run my 2D reaction-diffusion models, each simulation takes a minute or two to run, making use of multiple CPU cores. On past experience, I'd expect these programs to run about an order of magnitude slower in Python or MATLAB. In practice, rather than waiting longer, I would limit the resolution, or scope of the model to keep the time it required to run at an optimum value. A batch of simulations running overnight is much more useful than a batch which needs a week to complete. However, by limiting the scope of the model, I might be ignoring science that would only present itself in a higher resolution system.  Put simply, using c++ allows me to get the most out of the computer hardware I have access to.\"), mdx(\"p\", null, \"Even if there's a clear case for using compiled code to simulate, it's not a given that the data should be visualised this way. A common approach is to have the compiled program write data into a file (plug: I use \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/ABRG-Models/morphologica/blob/main/morph/HdfData.h\"\n  }, \"morph::HdfData\"), \" to write HDF5 files), and then use Python or R to construct the graphs. This is perfectly sensible for generating graphs for a journal or report, but it can be clunky when visualising to inspect the model.  Model inspection is a manual exploration of the model, watching its behaviour for hand-selected parameter choices. This process of manual exploration is part of the development of every model. First, it's essential to verify that the code works as expected and that it expresses the mathematics of the model correctly. The ability to graph the state of the internal variables of the model, possibly from one timestep to the next, is exceedingly helpful as part of the debugging process. Once the model is generating believable output, manual exploration  can aid the researcher in determining suitable parameter ranges over which the model is stable. I find this important for planning batched parameter searches or parameter optimisations. If the model is dynamic, it is also very helpful to see the dynamics unfold in real-time and to have the ability to create movies of the simulation. For these reasons, I consider it a necessity to be able to visualise data in c++ simulations. \"), mdx(\"p\", null, \"Unfortunately, there's no natural choice of library for graphing with c++; nothing quite as ubiquitous as matplotlib for Python. \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://alandefreitas.github.io/matplotplusplus/\"\n  }, \"matplot++\"), \" is probably the most mature graphing library for c++, though it appears to be somewhat of a clone of matplotlib, intended for drawing static graphs for publication, and I find it hard to see why you wouldn't just graph with matplotlib itself, for convenience. In my work, during the debugging process I may need visualisations of three-dimensional surfaces in models with as many as 100 state variables. In other words, to watch the full model may involve plotting a hundred 3D graphs at once! Not only do I need to visualise my data, I need to do so with minimal use of the processor. This need for efficient data visualisation motivated me to develop the from-scratch graphing code found in morphologica.\"), mdx(\"p\", null, \"To write the code, I was inspired by gaming technology. My kids play a game called Garry's Mod. Garry's Mod isn't actually a game at all, it's a physics sandbox; a 3D environment into which you can place models with which you can interact. Really, it's an example of a game engine. I imagined building a similar world into which I could place graph models which would update as my simulations progressed. I wanted to fly around the graphs, viewing them from any angle and bringing as many into the view as necessary. A lot of the work rendering the scene would be carried out on my graphics processor, leaving my CPU free to compute the model. The output of the visualisation, which could be captured as screenshots, wouldn't necessarily need to be of publication quality - a traditional approach using Python and matplotlib could be used to generate additional analysis and final graphs for a paper.\"), mdx(\"p\", null, \"For this 'game engine for visualisation', I chose the name \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/ABRG-Models/morphologica/blob/main/morph/Visual.h\"\n  }, \"morph::Visual\"), \". The code would form part of morphologica, a collection of simulation support facilities whose namespace name is morph (morphologica suggests simulations relating to morphology, a theme in our group). I chose to use modern OpenGL to program the graphics, because it is cross-platform, well established and efficient. The modern in the name indicates that a special shader program, which runs on the GPU, must be written to update the view of the scene. In OpenGL, everything is drawn as triangles. A line is two long, thin triangles. A sphere is a grid of triangles; mine have a fan at the top of the sphere, then rings from the top to the bottom, with a final fan finishing the sphere off, which seemed easier than making a truncated icosahedron! It's a very low-level approach to graphics, and no small task to develop from scratch, but initially, all I needed was surfaces made up of hexagons, which are easily constructed from triangles.\"), mdx(\"p\", null, \"I chose an architecture in which each graph visualisation was a class derived from a base class called \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/ABRG-Models/morphologica/blob/main/morph/VisualModel.h\"\n  }, \"morph::VisualModel\"), \". The first VisualModels were \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/ABRG-Models/morphologica/blob/main/morph/HexGridVisual.h\"\n  }, \"HexGridVisual\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/ABRG-Models/morphologica/blob/main/morph/CoordArrows.h\"\n  }, \"CoordArrows\"), \"; these were the only objects in my first scenes. Later, I added other VisualModels, including \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/ABRG-Models/morphologica/blob/main/morph/GraphVisual.h\"\n  }, \"morph::GraphVisual\"), \", which makes it easy to create a regular 2D line or scatter graph. This has given me the opportunity to try to develop a more intuitive API than the one provided by matplotlib in Python (and copied in matplot++), which I have always found confusing (there always seem to be too many ways to achieve a result). In morph::Visual, I can make decisions about how I think the API should work and I can favour simplicity over flexibility.\"), mdx(\"img\", {\n    alt: \"A three dimensional surface being rendered by morph::Visual at high speed\",\n    src: \"/cfb95ea008addc89a378c35355763e6c/Surface.png\"\n  }), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"A three dimensional surface being rendered by morph::Visual at high speed (see \", mdx(\"a\", {\n    parentName: \"em\",\n    \"href\": \"https://github.com/ABRG-Models/morphologica/blob/main/examples/fps.cpp\"\n  }, \"examples/fps.cpp\"), \"). The 'simulation' here is minimally computationally expensive - it consists of evaluating sin(kr)/kr across the surface, where r is the distance to the centre and k is an incrementing constant, at each frame - so it gives a good indication of the performance of the visualisation code itself\"), \".\"), mdx(\"p\", null, \"The results have been very satisfying. I am able to run huge visualisations with more than 50 3D graphs. A surface plot containing 145000 coordinates can be updated and visualised at 4K screen resolution in as little as 4.3 milliseconds of compute time (see the morphologica \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/ABRG-Models/morphologica/blob/main/examples/fps.cpp\"\n  }, \"examples/fps.cpp\"), \"). The API to create a graph object and then update the data being displayed is straightforward to use. Anyone using the code gets all the 'hard stuff' for free - projecting the data, reverse projecting mouse movements to give an intuitive user interface, lighting effects in the shader, nice colour maps and the ability to use TrueType text (which is a big faff in OpenGL!) are all handled for you. The code is header-only, and the TrueType fonts used for text rendering are all compiled into your binaries, avoiding annoying 'resource not available' runtime messages.\"), mdx(\"img\", {\n    alt: \"A plot of a reaction-diffusion simulation containing 2 state variables, n and c.\",\n    src: \"/e3894ca278407b744059dd5fa168dc0c/Ermentrout.png\"\n  }), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"A plot of a reaction-diffusion simulation containing 2 state variables, n and c. This example contains a GraphVisual graph alongside the 3D surfaces, showing how some objects in the scene can be rotated while the 2D graph remains flat. (See \", mdx(\"a\", {\n    parentName: \"em\",\n    \"href\": \"https://github.com/ABRG-Models/morphologica/blob/main/examples/Ermentrout2009/erm.cpp\"\n  }, \"examples/Ermentrout2009/erm.cpp\"), \")\")), mdx(\"p\", null, \"Morphologica is in use across our research group, but it is emphatically not intended to be limited to any particular field of research and we'd love to see others making use of it. You'll find that it's a useful library of 'simulation support facilities' and I warmly invite you to try it out in your own c++ simulation code.\"), mdx(\"hr\", null), mdx(\"div\", {\n    className: \"flex flex-wrap p-2 items-center\"\n  }, mdx(\"div\", {\n    className: \"flex flex-wrap w-full items-center\"\n  }, mdx(\"div\", {\n    className: \"md:w-1/6 md:mx-auto\"\n  }, mdx(\"img\", {\n    src: \"/1b950aec9371d81fecb003f21d10c274/Seb_J.jpg\",\n    alt: \"Seb James thumbnail\",\n    className: \"rounded-lg\"\n  })), mdx(\"div\", {\n    className: \"md:w-5/6 p-2 lg:p-6\"\n  }, mdx(\"div\", {\n    className: \"my-1 font-bold text-2xl flex items-center\"\n  }, \"Seb James\", mdx(\"div\", {\n    className: \"inline-block ml-4\"\n  }, mdx(TwitterBtn, {\n    href: \"https://twitter.com/intent/follow?screen_name=sebjames\",\n    mdxType: \"TwitterBtn\"\n  }))), mdx(\"p\", {\n    className: \"my-0\"\n  }, \"Research Associate\"), mdx(\"p\", {\n    className: \"my-0\"\n  }, \"Department of Psychology\"), mdx(\"p\", {\n    className: \"my-0\"\n  }, \"The University of Sheffield\"))), mdx(\"div\", null, mdx(\"p\", {\n    className: \"text-gray-900\"\n  }, \" I am one of the Psychology Department's computational researchers. Working in Stuart P. Wilson's group, I study the \", mdx(\"em\", null, \" ontogeny \"), \" of the brain. Ontogeny is the process by which an organism develops from inception to adulthood. It poses the question of how the complex structure that is an adult organism self organises, instructed only by the genetic information stored in the DNA of the initial, fertilised egg cell. I try to imagine mechanisms by which this can be achieved and I write computer programs to express these ideas. In this sense, I am carrying out large, computerised thought experiments to find out how the patterning of biology can be achieved reliably (with all individuals looking the same) and how this process can be manipulated by evolutionary selection (thus, crossing over into the study of phylogeny).\"))));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{},"fields":{"slug":"/blog/25/01/2021/Morphologica","readingTime":{"text":"11 min read"},"slugOrigin":"/2021-01-26-Morphologica/"},"frontmatter":{"type":null,"title":"Data visualisation in c++ with computational models","date":"25 January 2021","description":"In this blog post I'm going to talk about data visualisation - making graphs - within c++ programs. I'll describe why you might want to do this and I'll try to justify why I've spent a sizeable part of my time over the last couple of years developing graphing code in c++, rather than using Python or R like everyone else!","tag":["Dataviz","C++","Interactive"],"category":["Articles"],"featured":true,"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","backgroundColor":"#080808","images":{"fallback":{"src":"/static/cfb95ea008addc89a378c35355763e6c/bf945/Surface.png","srcSet":"/static/cfb95ea008addc89a378c35355763e6c/44444/Surface.png 750w,\n/static/cfb95ea008addc89a378c35355763e6c/bf945/Surface.png 1005w","sizes":"100vw"},"sources":[{"srcSet":"/static/cfb95ea008addc89a378c35355763e6c/12950/Surface.webp 750w,\n/static/cfb95ea008addc89a378c35355763e6c/b3e6f/Surface.webp 1005w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.6597014925373135}}},"author":[{"name":"Seb James","avatar":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","backgroundColor":"#888878","images":{"fallback":{"src":"/static/1b950aec9371d81fecb003f21d10c274/1b894/Seb_J.jpg","srcSet":"/static/1b950aec9371d81fecb003f21d10c274/1b894/Seb_J.jpg 320w","sizes":"100vw"},"sources":[{"srcSet":"/static/1b950aec9371d81fecb003f21d10c274/5e011/Seb_J.webp 320w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":1}}}}],"disableTOC":null,"d3":null}}},"pageContext":{"id":"7e8ffaac-7f17-55de-9778-13887c6e9f24","slug":"/blog/25/01/2021/Morphologica","prev":{"node":{"id":"1ba094c2-7442-5784-8390-b139332c2bdd","fields":{"slug":"/blog/27/01/2021/Interactive-Visualisations-In-R"},"frontmatter":{"template":null,"title":"Interactive Visualisations in R","date":"Wednesday 27th January 2021","category":["Articles"],"tag":["R","Plotly","Shiny","Interactive"],"d3":null,"type":null,"published":null}}},"next":{"node":{"id":"43252686-36d1-5164-9d9a-50c42fc02bff","fields":{"slug":"/blog/20/01/2021/Static-Visualisations-In-R"},"frontmatter":{"template":null,"title":"Static Visualisations in R","date":"Wednesday 20th January 2021","category":["Articles"],"tag":["R","Tidyverse","ggplot2","ggpubr","rgl","Lattice"],"d3":null,"type":null,"published":null}}}}},
    "staticQueryHashes": ["160810946","3815917638","3976606562"]}